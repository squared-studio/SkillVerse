# Finite State Machines (FSMs)

This chapter focuses on Finite State Machines (FSMs), a fundamental concept in digital design used to control the sequential behavior of digital systems. FSMs are essential for implementing control logic in a wide range of applications, from simple controllers to complex communication protocols and processor designs. This chapter covers FSM theory, design methodologies, RTL implementation, and best practices.

*   **Finite State Machine Concepts and Applications:**
    *   **Definition of FSM:**
        - A sequential circuit whose outputs and next state depend not only on the current inputs but also on its current state.
        - Characterized by a finite number of states, transitions between states, and outputs associated with states or transitions.
        - Mathematical model of computation used to design digital control systems.
    *   **Key Components of an FSM:**
        - **States:**  Represent different modes of operation or stages in a process. An FSM can be in only one state at any given time.
        - **Inputs:** External signals that can cause the FSM to transition from one state to another or affect its outputs.
        - **Outputs:** Signals generated by the FSM to control other parts of the system or indicate its current status.
        - **Transitions:** Rules that define how the FSM moves from one state to another based on current state and inputs.
        - **Next State Logic:** Combinational logic that determines the next state based on the current state and inputs.
        - **Output Logic:** Combinational logic that generates the outputs based on the current state (Moore FSM) or current state and inputs (Mealy FSM).
    *   **Applications of FSMs:**
        - **Control Logic:**  Implementing control units in CPUs, microcontrollers, and peripheral devices.
        - **Communication Protocols:**  Designing controllers for UART, SPI, I2C, Ethernet, USB, etc.
        - **Sequence Detection:**  Recognizing specific patterns in input data streams.
        - **Traffic Light Controllers, Vending Machines, Elevators:**  Classic examples of systems controlled by FSMs.
        - **Digital Signal Processing (DSP) Control:**  Managing data flow and processing steps in DSP algorithms.
        - **Arbitration Logic:**  Resolving conflicts when multiple masters request access to a shared resource.

*   **Mealy vs. Moore FSMs:**
    *   **Moore FSM:**
        - Outputs are determined *only* by the current state.
        - Output logic is a function of the state register only.
        - State transitions depend on current state and inputs.
        - Advantages: Simpler output logic, outputs are stable for the entire state duration, less prone to glitches on outputs.
        - Disadvantages: May require more states for some designs, output changes are delayed by one clock cycle relative to input changes.
    *   **Mealy FSM:**
        - Outputs are determined by *both* the current state *and* the current inputs.
        - Output logic is a function of both state register and inputs.
        - State transitions depend on current state and inputs.
        - Advantages: Can be more efficient in terms of the number of states required for some designs, outputs can react faster to inputs (no one-clock cycle delay).
        - Disadvantages: More complex output logic, outputs can be glitchy if inputs change during a state, timing can be more critical for output logic.
    *   **Choosing between Mealy and Moore:**
        - Moore FSMs are often preferred when output stability and simplicity are important.
        - Mealy FSMs can be more efficient in terms of state count and response time in certain applications where output glitches are acceptable or can be filtered.
        - Many designs use a combination of Moore and Mealy FSM concepts in different parts of the control logic.

*   **State Diagrams and State Transition Tables:**
    *   **State Diagrams:**
        - Graphical representation of an FSM.
        - States are represented as circles or bubbles, labeled with state names.
        - Transitions are represented as directed arrows between states, labeled with input conditions that trigger the transition and (for Mealy FSMs) output values.
        - Start state is typically indicated with a special arrow.
        - Visual and intuitive way to represent FSM behavior, especially for simpler FSMs.
    *   **State Transition Tables:**
        - Tabular representation of an FSM.
        - Rows represent current states, columns represent input combinations.
        - Entries in the table specify the next state and (for Mealy FSMs) the output values for each combination of current state and inputs.
        - More structured and precise than state diagrams, especially for complex FSMs. Easier to use for RTL coding.
    *   **Example: Traffic Light Controller (Simple Moore FSM):**
        - **States:** Green, Yellow, Red.
        - **Inputs:** Clock, Timer (signals when a timer expires).
        - **Outputs:**  Traffic light signals (Green_light, Yellow_light, Red_light for two directions - Main Street and Side Street).
        - **State Diagram (Conceptual):**
            - Green State: Main Street Green, Side Street Red. Transition to Yellow when timer expires.
            - Yellow State: Main Street Yellow, Side Street Red. Transition to Red after a short delay.
            - Red State: Main Street Red, Side Street Green. Transition to Green after a longer delay.
        - **State Transition Table (Conceptual):**

            | Current State | Timer Expired? | Next State | Main Street Lights | Side Street Lights |
            | :------------ | :------------- | :--------- | :----------------- | :----------------- |
            | Green         | No             | Green      | Green              | Red                |
            | Green         | Yes            | Yellow     | Green              | Red                |
            | Yellow        | No             | Red        | Yellow             | Red                |
            | Red           | No             | Green      | Red                | Green              |

*   **RTL Implementation of FSMs in SystemVerilog (using `case` statements):**
    *   **General FSM RTL Structure:**
        - State register:  `reg [STATE_BITS-1:0] current_state, next_state;` (or `logic state_t current_state, next_state;` using enumerated types).
        - Sequential `always_ff` block: For state register update at clock edge.
            ```SV
            always_ff @(posedge clk) begin
                if (rst) begin
                    current_state <= initial_state;
                end else begin
                    current_state <= next_state;
                end
            end
            ```
        - Combinational `always_comb` block: For next state logic and output logic.
            - For Moore FSM: Output logic is based on `current_state` only.
            - For Mealy FSM: Output logic is based on `current_state` and inputs.
            ```SV
            always_comb begin
                next_state = current_state; // Default next state (state retention)
                output_signal = ... ;       // Output logic (Moore or Mealy)
                case (current_state)
                    state1: begin
                        if (input_condition1) next_state = state2;
                        else if (input_condition2) next_state = state3;
                        // ... other transitions from state1 ...
                        output_signal = ... ; // Moore output logic for state1
                    end
                    state2: begin
                        // ... transitions and Moore output logic for state2 ...
                    end
                    // ... cases for other states ...
                    default: next_state = initial_state; // Default case for robustness
                endcase
            end
            ```
    *   **SystemVerilog `case` statement for State Transitions:**
        - `case` statement is well-suited for implementing FSM state transitions.
        - Each `case` item corresponds to a state.
        - Within each state's `begin...end` block, `if-else` or nested `case` statements can be used to define transitions based on input conditions.
        - Include a `default` case in the `case` statement to handle unexpected or illegal states, and to ensure complete assignment of `next_state`.

*   **State Encoding Techniques (Binary, Gray, One-Hot):**
    *   **State Encoding:** Assigning binary codes to represent each state in the FSM's state register. Different encoding schemes can impact area, power, and performance.
    *   **Binary Encoding:**
        - States are encoded using a minimum number of bits required to represent all states in binary form.
        - Example: 4 states can be encoded using 2 bits (00, 01, 10, 11).
        - Area-efficient in terms of state register bits.
        - Combinational logic for next state and output logic can be complex and may lead to glitches.
    *   **Gray Encoding:**
        - Adjacent states in the state transition sequence differ by only one bit in their encoding.
        - Reduces the number of bit transitions during state changes, potentially lowering power consumption.
        - Can sometimes simplify combinational logic compared to binary encoding, but not always.
    *   **One-Hot Encoding:**
        - Each state is represented by a unique flip-flop. Only one flip-flop is active (set to '1') for each state, and all others are inactive ('0').
        - Example: For 4 states, use 4 flip-flops. State 1: 0001, State 2: 0010, State 3: 0100, State 4: 1000.
        - Advantages: Simplifies next state and output logic, faster transitions between states (only one flip-flop changes state per transition), easier debugging.
        - Disadvantages: Uses more flip-flops (less area-efficient for state register), may increase power consumption if many states and frequent transitions.
    *   **Choosing State Encoding:**
        - Binary encoding is often a good default choice for area efficiency when state count is high.
        - One-hot encoding can be beneficial for speed and simplifying logic, especially for FPGAs where flip-flops are abundant.  Good for complex FSMs with many states and transitions.
        - Gray encoding is primarily used for low-power applications where state transitions are frequent.
        - Synthesis tools often have options to automatically choose or optimize state encoding based on design characteristics and constraints.

*   **FSM Design Best Practices (Completeness, Avoiding Deadlocks):**
    *   **Completeness:**
        - Specify transitions for all possible combinations of current states and relevant inputs.
        - Include a `default` case in `case` statements for state transitions to handle unexpected or illegal input conditions and ensure that `next_state` is always assigned a valid state.
        - Avoid implicit state retention (unintentional latches) by explicitly assigning `next_state` in all branches of conditional logic.
    *   **Avoiding Deadlocks:**
        - Ensure that there are no states or sets of states from which the FSM cannot escape. Every state should have a path to eventually reach a desired state (e.g., an idle or initial state).
        - Carefully design transitions to guarantee forward progress and prevent the FSM from getting stuck in a loop of undesirable states.
        - Consider reset and error handling mechanisms to recover from unexpected situations or invalid states.
    *   **State Minimization (Optional, for advanced design):**
        - For complex FSMs, state minimization techniques can be used to reduce the number of states without changing the FSM's functionality.
        - Reduces complexity of implementation and can improve area and performance.
        - Tools and algorithms exist for state minimization, but for many RTL designs, manual state minimization based on careful analysis is sufficient.
    *   **Design Verification:**
        - Thoroughly verify FSM behavior through simulation.
        - Test all states, transitions, and outputs under various input sequences and conditions.
        - Use assertions to formally check FSM properties and correct state transitions.

## Learning Resources

*   **Textbook chapters on Finite State Machines in digital design books:**
    *   **Search Query Suggestion:** Search for "finite state machine digital design textbook," "sequential logic FSM chapter," "digital circuits state machines."
    *   **Textbook Examples:** Refer to digital design textbooks mentioned in earlier chapters (Harris & Harris, Mano, Brown & Vranesic). Look for chapters specifically on "Sequential Logic Design," "Finite State Machines," or "State Machine Design."
    *   **Focus on Theory and Examples:** Textbooks will provide theoretical background on FSMs, Mealy vs. Moore models, state diagrams, state tables, and design examples.

*   **Online tutorials and articles on FSM design in RTL:**
    *   **Search Query Suggestion:** Search for "FSM design RTL tutorial," "SystemVerilog FSM coding," "Verilog state machine examples," "FSM implementation in FPGA," "one-hot encoding FSM."
    *   **Look for Practical Examples:** Online tutorials often provide step-by-step guides and code examples for implementing FSMs in SystemVerilog or VHDL. Look for examples of different types of FSMs (Moore, Mealy) and different state encoding techniques.

*   **Examples of FSM implementations in open-source RTL projects (e.g., on GitHub):**
    *   **GitHub ([GitHub: Where the world builds software Â· GitHub](https://github.com/))**
        - Search on GitHub using keywords like "SystemVerilog FSM," "Verilog state machine," "RTL FSM examples," "open source FSM."
        - **Explore Project Repositories:** Look for repositories containing RTL designs for CPUs, peripherals, communication interfaces, or other digital systems. These projects often include FSM implementations for control logic.
        - **Study FSM Code:** Examine the RTL code for FSM modules in these projects. Pay attention to how states are defined, how state transitions are implemented using `case` statements, and how outputs are generated. Note different coding styles and state encoding choices.

## Exercises

*   **Design an FSM for a simple traffic light controller:**
    *   **Functionality:** Implement a traffic light controller for a two-way intersection (Main Street and Side Street).
    *   **States:** Define states like `GREEN_MAIN`, `YELLOW_MAIN`, `RED_MAIN_GREEN_SIDE`, `YELLOW_SIDE`, `RED_SIDE_GREEN_MAIN`.  (You can simplify or expand states as needed).
    *   **Inputs:** Clock, Timer signal (to indicate when to change lights).
    *   **Outputs:**  Traffic light signals for Main Street (Main_Green, Main_Yellow, Main_Red) and Side Street (Side_Green, Side_Yellow, Side_Red).
    *   **State Diagram/Table:**  Create a state diagram or state transition table to define the traffic light sequence and transitions.
    *   **RTL Implementation:** Implement the FSM in SystemVerilog using `always_ff` for state updates and `always_comb` for next state and output logic. Use a `case` statement for state transitions. Choose Moore FSM for simplicity.
    *   **Testbench:** Write a testbench to simulate the traffic light controller. Verify the correct sequence of lights, transitions based on timer input, and proper cycling through states.

*   **Design an FSM for a sequence detector:**
    *   **Functionality:** Design an FSM that detects a specific sequence of input bits (e.g., "1011").
    *   **Input:** Serial data input (`data_in`), Clock.
    *   **Output:** `sequence_detected` signal (asserted when the sequence "1011" is detected).
    *   **States:** Define states to represent the progress in detecting the sequence. For example: `S_START`, `S_1_MATCHED`, `S_10_MATCHED`, `S_101_MATCHED`, `S_SEQUENCE_DETECTED`.
    *   **State Diagram/Table:** Create a state diagram or table showing transitions based on input data and current state. Consider transitions for both correct and incorrect input bits.
    *   **RTL Implementation:** Implement the sequence detector FSM in SystemVerilog. Choose either Moore or Mealy FSM implementation. Use `case` statement for state transitions.
    *   **Testbench:** Write a testbench to verify the sequence detector. Test with input sequences that contain the target sequence and sequences that do not. Verify that `sequence_detected` output is asserted correctly only when the target sequence is detected.

*   **Implement the same FSM using different state encoding styles and compare synthesis results:**
    *   **Choose One FSM Design:** Select either the traffic light controller or the sequence detector FSM designed in the previous exercises.
    *   **Implement with Binary Encoding:** Implement the FSM using binary state encoding (let synthesis tool automatically assign binary codes, or manually assign binary codes).
    *   **Implement with One-Hot Encoding:** Implement the same FSM using one-hot state encoding. Explicitly define state encodings using parameters or `localparam` and assign one-hot codes to each state.
    *   **Synthesis:** Synthesize both implementations (binary and one-hot) using a synthesis tool (e.g., Vivado Synthesis or Quartus Prime). Use the same target technology and constraints for both syntheses.
    *   **Compare Synthesis Reports:** Compare the synthesis reports for area (number of flip-flops, LUTs) and timing (critical path delay) for both implementations.
    *   **Analyze Results:** Discuss the trade-offs between binary and one-hot encoding in terms of area and performance for the specific FSM design. Observe how state encoding choices can impact implementation characteristics.

##### Copyright (c) 2025 squared-studio

